/* AUTOMATICALLY GENERATED CODE DO NOT MODIFY */
/*   To generate run: `serverpod generate`    */

// ignore_for_file: library_private_types_in_public_api
// ignore_for_file: public_member_api_docs
// ignore_for_file: implementation_imports
// ignore_for_file: use_super_parameters
// ignore_for_file: type_literal_in_constant_pattern

library protocol;

import 'package:serverpod/serverpod.dart' as _i1;

class Device extends _i1.TableRow {
  Device._({
    int? id,
    required this.name,
    required this.location,
    required this.status,
    DateTime? createdAt,
    DateTime? updatedAt,
  })  : createdAt = createdAt ?? DateTime.now(),
        updatedAt = updatedAt ?? DateTime.now(),
        super(id);

  factory Device({
    int? id,
    required String name,
    required String location,
    required String status,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) = Device._;

  factory Device.fromJson(Map<String, dynamic> jsonSerialization) {
    return Device(
      id: jsonSerialization['id'] as int?,
      name: jsonSerialization['name'] as String,
      location: jsonSerialization['location'] as String,
      status: jsonSerialization['status'] as String,
      createdAt: jsonSerialization['createdAt'] == null
          ? null
          : DateTime.parse(jsonSerialization['createdAt'] as String),
      updatedAt: jsonSerialization['updatedAt'] == null
          ? null
          : DateTime.parse(jsonSerialization['updatedAt'] as String),
    );
  }

  static final t = DeviceTable();

  static const db = DeviceRepository._();

  String name;
  String location;
  String status; // online, warning, offline
  DateTime createdAt;
  DateTime updatedAt;

  @override
  _i1.Table get table => t;

  Device copyWith({
    int? id,
    String? name,
    String? location,
    String? status,
    DateTime? createdAt,
    DateTime? updatedAt,
  });

  @override
  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'id': id,
      'name': name,
      'location': location,
      'status': status,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
    };
  }

  @override
  Map<String, dynamic> toJsonForProtocol() {
    return {
      if (id != null) 'id': id,
      'name': name,
      'location': location,
      'status': status,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
    };
  }
}

class DeviceTable extends _i1.Table {
  DeviceTable({super.tableRelation}) : super(tableName: 'devices') {
    name = _i1.ColumnString('name');
    location = _i1.ColumnString('location');
    status = _i1.ColumnString('status');
    createdAt = _i1.ColumnDateTime('createdAt');
    updatedAt = _i1.ColumnDateTime('updatedAt');
  }

  late final _i1.ColumnString name;
  late final _i1.ColumnString location;
  late final _i1.ColumnString status;
  late final _i1.ColumnDateTime createdAt;
  late final _i1.ColumnDateTime updatedAt;

  @override
  List<_i1.Column> get columns => [
        id,
        name,
        location,
        status,
        createdAt,
        updatedAt,
      ];
}

class DeviceRepository {
  const DeviceRepository._();

  Future<List<Device>> find(
    _i1.Session session, {
    _i1.WhereExpressionBuilder<DeviceTable>? where,
    int? limit,
    int? offset,
    _i1.OrderByBuilder<DeviceTable>? orderBy,
  }) async {
    return session.db.find<Device>(
      where: where?.call(Device.t),
      orderBy: orderBy?.call(Device.t),
      limit: limit,
      offset: offset,
    );
  }

  Future<Device?> findFirstRow(
    _i1.Session session, {
    _i1.WhereExpressionBuilder<DeviceTable>? where,
    int? offset,
    _i1.OrderByBuilder<DeviceTable>? orderBy,
  }) async {
    return session.db.findFirstRow<Device>(
      where: where?.call(Device.t),
      orderBy: orderBy?.call(Device.t),
      offset: offset,
    );
  }

  Future<Device?> findById(
    _i1.Session session,
    int id,
  ) async {
    return session.db.findById<Device>(id);
  }

  Future<List<Device>> insert(
    _i1.Session session,
    List<Device> rows,
  ) async {
    return session.db.insert<Device>(rows);
  }

  Future<Device> insertRow(
    _i1.Session session,
    Device row,
  ) async {
    return session.db.insertRow<Device>(row);
  }

  Future<List<Device>> update(
    _i1.Session session,
    List<Device> rows,
  ) async {
    return session.db.update<Device>(rows);
  }

  Future<Device> updateRow(
    _i1.Session session,
    Device row,
  ) async {
    return session.db.updateRow<Device>(row);
  }

  Future<List<Device>> delete(
    _i1.Session session,
    List<Device> rows,
  ) async {
    return session.db.delete<Device>(rows);
  }

  Future<Device> deleteRow(
    _i1.Session session,
    Device row,
  ) async {
    return session.db.deleteRow<Device>(row);
  }

  Future<List<Device>> deleteWhere(
    _i1.Session session, {
    required _i1.WhereExpressionBuilder<DeviceTable> where,
  }) async {
    return session.db.deleteWhere<Device>(
      where: where(Device.t),
    );
  }

  Future<int> count(
    _i1.Session session, {
    _i1.WhereExpressionBuilder<DeviceTable>? where,
  }) async {
    return session.db.count<Device>(
      where: where?.call(Device.t),
    );
  }
}